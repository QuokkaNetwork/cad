const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const { Settings } = require('../db/sqlite');

const RESOURCE_NAME = 'cad_bridge';

// ── voice.cfg auto-deploy ─────────────────────────────────────────────────

/**
 * The canonical voice.cfg template lives at the repo root (voice.cfg).
 * We read it, substitute the IP/port/token values from .env, then write
 * the result into the FiveM server folder alongside server.cfg.
 * This keeps voice.cfg in sync automatically on every CAD restart/sync.
 */
const VOICE_CFG_TEMPLATE = path.resolve(__dirname, '../../../voice.cfg');

function getVoiceCfgConfig() {
  // FIVEM_SERVER_PATH: path to the FiveM server root (the folder that
  // contains server.cfg). CAD writes voice.cfg here and keeps it in sync.
  const serverPath = String(process.env.FIVEM_SERVER_PATH || '').trim().replace(/^"(.*)"$/, '$1');
  const publicIp   = String(process.env.MUMBLE_PUBLIC_IP || process.env.MUMBLE_HOST || '').trim();
  const port       = parseInt(process.env.MUMBLE_PORT || '64738', 10) || 64738;
  const token      = getSetting('fivem_bridge_shared_token', process.env.FIVEM_BRIDGE_SHARED_TOKEN || '');
  // Bridge URL defaults to the HTTP-only port 3031 so FiveM's PerformHttpRequest
  // works without TLS. The main CAD server serves HTTPS on port 3030 for browsers.
  const bridgeHttpPort = parseInt(process.env.BRIDGE_HTTP_PORT || '3031', 10) || 3031;
  const baseUrl    = getSetting('fivem_bridge_base_url', `http://127.0.0.1:${bridgeHttpPort}`);
  return { serverPath, publicIp, port, token, baseUrl };
}

function buildVoiceCfgContent(publicIp, port, token, baseUrl) {
  if (!fs.existsSync(VOICE_CFG_TEMPLATE)) {
    return generateVoiceCfgInline(publicIp, port, token, baseUrl);
  }
  let content = fs.readFileSync(VOICE_CFG_TEMPLATE, 'utf8');

  // Substitute the public IP (quoted)
  content = content.replace(
    /^(setr\s+voice_externalAddress\s+)".+?"/m,
    `$1"${publicIp}"`
  );
  // Substitute the port
  content = content.replace(
    /^(setr\s+voice_externalPort\s+)\S+/m,
    `$1${port}`
  );
  // Substitute the CAD bridge token
  content = content.replace(
    /^(set\s+cad_bridge_token\s+)".+?"/m,
    `$1"${token}"`
  );
  // Substitute the CAD bridge base URL
  content = content.replace(
    /^(set\s+cad_bridge_base_url\s+)".+?"/m,
    `$1"${baseUrl}"`
  );
  return content;
}

function generateVoiceCfgInline(publicIp, port, token, baseUrl) {
  return [
    '# Auto-generated by CAD — do not edit manually, changes will be overwritten.',
    '# To customise: change MUMBLE_PUBLIC_IP / MUMBLE_PORT in CAD .env and restart CAD.',
    '',
    `setr voice_externalAddress "${publicIp}"`,
    `setr voice_externalPort ${port}`,
    'setr voice_allowSetIntent 1',
    'setr voice_hideEndpoints 1',
    'setr voice_useNativeAudio true',
    'setr voice_enableSubmix 1',
    'setr voice_defaultRadioVolume 100',
    'setr voice_enableRadios 0',
    '',
    `set cad_bridge_base_url "${baseUrl}"`,
    `set cad_bridge_token "${token}"`,
    '',
    'set cad_bridge_npwd_emergency_numbers "000"',
    'set cad_bridge_npwd_resource "npwd"',
    'set cad_bridge_fine_adapter "auto"',
    'set cad_bridge_job_sync_adapter "none"',
    'set cad_bridge_radio_adapter "cad-radio"',
    'set cad_bridge_radio_ui_enabled "true"',
    'set cad_bridge_radio_ui_key "EQUALS"',
    'set cad_bridge_radio_ptt_key "LMENU"',
    'set cad_bridge_radio_max_frequency "500"',
    '',
  ].join('\n');
}

function deployVoiceCfg() {
  const { serverPath, publicIp, port, token, baseUrl } = getVoiceCfgConfig();

  if (!serverPath) return; // FIVEM_SERVER_PATH not set — skip silently

  if (!publicIp || publicIp === '127.0.0.1') {
    console.warn('[VoiceCfg] FIVEM_SERVER_PATH is set but MUMBLE_PUBLIC_IP is not.');
    console.warn('[VoiceCfg] Set MUMBLE_PUBLIC_IP=<your VPS public IP> in .env.');
    console.warn('[VoiceCfg] Writing voice.cfg with placeholder IP — players will not be able to connect until this is fixed.');
  }

  const destPath = path.join(serverPath, 'voice.cfg');
  try {
    fs.mkdirSync(serverPath, { recursive: true });
    const content = buildVoiceCfgContent(publicIp || '0.0.0.0', port, token, baseUrl);
    const existed = fs.existsSync(destPath);
    fs.writeFileSync(destPath, content, 'utf8');
    console.log(`[VoiceCfg] voice.cfg ${existed ? 'updated' : 'created'} at ${destPath}`);
  } catch (err) {
    console.warn(`[VoiceCfg] Failed to write voice.cfg to ${destPath}: ${err.message}`);
  }
}

// ─────────────────────────────────────────────────────────────────────────────
const TEMPLATE_DIR = path.resolve(__dirname, '../../fivem-resource');
const VERSION_FILE_NAME = '.cad_bridge_version';
const OPTIONAL_MAP_RESOURCE_NAME = 'map';
const OPTIONAL_MAP_TEMPLATE_DIR = path.resolve(__dirname, '../../../map');
const OPTIONAL_MAP_VERSION_FILE_NAME = '.cad_map_version';
let syncInterval = null;

function getSetting(key, fallback = '') {
  const value = Settings.get(key);
  if (value === undefined || value === null || value === '') return fallback;
  return String(value);
}

function normalizePath(input) {
  return String(input || '').trim().replace(/^"(.*)"$/, '$1');
}

function getConfig() {
  return {
    enabled: getSetting('fivem_bridge_enabled', 'false').toLowerCase() === 'true',
    autoUpdate: getSetting('fivem_bridge_auto_update', 'true').toLowerCase() === 'true',
    installPath: normalizePath(getSetting('fivem_bridge_install_path', '')),
    syncIntervalMinutes: Math.max(1, parseInt(getSetting('fivem_bridge_sync_interval_minutes', '5'), 10) || 5),
  };
}

function ensureTemplateExists() {
  if (!fs.existsSync(TEMPLATE_DIR)) {
    throw new Error(`FiveM resource template not found at ${TEMPLATE_DIR}`);
  }
  if (!fs.existsSync(path.join(TEMPLATE_DIR, 'fxmanifest.lua'))) {
    throw new Error('Invalid FiveM resource template (missing fxmanifest.lua)');
  }
}

function resourceHasManifest(resourceDir) {
  if (!resourceDir || !fs.existsSync(resourceDir)) return false;
  return fs.existsSync(path.join(resourceDir, 'fxmanifest.lua'))
    || fs.existsSync(path.join(resourceDir, '__resource.lua'));
}

function listFilesRecursively(rootDir) {
  const files = [];
  function walk(current, prefix = '') {
    const entries = fs.readdirSync(current, { withFileTypes: true });
    for (const entry of entries) {
      const rel = prefix ? path.posix.join(prefix, entry.name) : entry.name;
      const abs = path.join(current, entry.name);
      if (entry.isDirectory()) {
        walk(abs, rel);
      } else if (entry.isFile()) {
        files.push({ rel, abs });
      }
    }
  }
  walk(rootDir);
  return files.sort((a, b) => a.rel.localeCompare(b.rel));
}

function buildTemplateHash(rootDir = TEMPLATE_DIR) {
  const hash = crypto.createHash('sha256');
  for (const file of listFilesRecursively(rootDir)) {
    hash.update(file.rel);
    hash.update(fs.readFileSync(file.abs));
  }
  return hash.digest('hex');
}

function resolveTargetDir() {
  const { installPath } = getConfig();
  if (!installPath) throw new Error('fivem_bridge_install_path is not configured');
  return path.join(path.resolve(installPath), RESOURCE_NAME);
}

function escapeLuaSingleQuoted(value) {
  return String(value || '')
    .replace(/\\/g, '\\\\')
    .replace(/'/g, "\\'");
}

function applyRuntimeConfig(targetDir) {
  const configPath = path.join(targetDir, 'config.lua');
  if (!fs.existsSync(configPath)) return;

  const _bridgeHttpPort = parseInt(process.env.BRIDGE_HTTP_PORT || '3031', 10) || 3031;
  const baseUrl = getSetting('fivem_bridge_base_url', `http://127.0.0.1:${_bridgeHttpPort}`);
  const token = getSetting('fivem_bridge_shared_token', '');
  const escapedBaseUrl = escapeLuaSingleQuoted(baseUrl);
  const escapedToken = escapeLuaSingleQuoted(token);

  let content = fs.readFileSync(configPath, 'utf8');
  content = content.replace(
    /^Config\.CadBaseUrl\s*=.*$/m,
    `Config.CadBaseUrl = GetConvar('cad_bridge_base_url', '${escapedBaseUrl}')`
  );
  content = content.replace(
    /^Config\.SharedToken\s*=.*$/m,
    `Config.SharedToken = GetConvar('cad_bridge_token', '${escapedToken}')`
  );
  content = content.replace(
    /^Config\.PublishAllPlayers\s*=.*$/m,
    "Config.PublishAllPlayers = GetConvar('cad_bridge_publish_all_players', 'true') == 'true'"
  );
  fs.writeFileSync(configPath, content, 'utf8');
}

function writeVersionFile(targetDir, version, fileName = VERSION_FILE_NAME) {
  const content = JSON.stringify({ version, updated_at: new Date().toISOString() }, null, 2);
  fs.writeFileSync(path.join(targetDir, fileName), content, 'utf8');
}

function readInstalledVersion(targetDir, fileName = VERSION_FILE_NAME) {
  const versionFile = path.join(targetDir, fileName);
  if (!fs.existsSync(versionFile)) return '';
  try {
    const parsed = JSON.parse(fs.readFileSync(versionFile, 'utf8'));
    return String(parsed.version || '');
  } catch {
    return '';
  }
}

function getOptionalMapStatus(targetRoot = '') {
  const available = resourceHasManifest(OPTIONAL_MAP_TEMPLATE_DIR);
  const targetDir = targetRoot ? path.join(targetRoot, OPTIONAL_MAP_RESOURCE_NAME) : '';

  const status = {
    resourceName: OPTIONAL_MAP_RESOURCE_NAME,
    available,
    targetDir,
    installed: false,
    upToDate: false,
    installedVersion: '',
    templateVersion: '',
  };

  if (!available || !targetRoot) return status;

  status.templateVersion = buildTemplateHash(OPTIONAL_MAP_TEMPLATE_DIR);
  status.installed = resourceHasManifest(targetDir);
  if (status.installed) {
    status.installedVersion = readInstalledVersion(targetDir, OPTIONAL_MAP_VERSION_FILE_NAME);
    status.upToDate = Boolean(status.installedVersion && status.installedVersion === status.templateVersion);
  }

  return status;
}

function installOrUpdateOptionalMapResource(targetRoot) {
  const status = getOptionalMapStatus(targetRoot);
  if (!status.available || !status.targetDir || !status.templateVersion) return null;

  if (!status.installed || !status.upToDate) {
    fs.mkdirSync(status.targetDir, { recursive: true });
    fs.cpSync(OPTIONAL_MAP_TEMPLATE_DIR, status.targetDir, { recursive: true, force: true });
    writeVersionFile(status.targetDir, status.templateVersion, OPTIONAL_MAP_VERSION_FILE_NAME);
  }

  return {
    resourceName: OPTIONAL_MAP_RESOURCE_NAME,
    targetDir: status.targetDir,
    version: status.templateVersion,
    installed: true,
    upToDate: true,
  };
}

function installOrUpdateResource() {
  ensureTemplateExists();
  const targetDir = resolveTargetDir();
  const targetRoot = path.dirname(targetDir);
  const version = buildTemplateHash();

  fs.mkdirSync(targetRoot, { recursive: true });
  fs.mkdirSync(targetDir, { recursive: true });

  fs.cpSync(TEMPLATE_DIR, targetDir, { recursive: true, force: true });
  applyRuntimeConfig(targetDir);
  writeVersionFile(targetDir, version);

  const resources = [{
    resourceName: RESOURCE_NAME,
    targetDir,
    version,
    installed: true,
    upToDate: true,
  }];
  const optionalMap = installOrUpdateOptionalMapResource(targetRoot);
  if (optionalMap) resources.push(optionalMap);

  return {
    resourceName: RESOURCE_NAME,
    targetDir,
    version,
    resources,
  };
}

function getStatus() {
  const cfg = getConfig();
  let installed = false;
  let upToDate = false;
  let installedVersion = '';
  let templateVersion = '';
  let targetDir = '';
  let optionalMap = getOptionalMapStatus('');
  let error = '';

  try {
    ensureTemplateExists();
    templateVersion = buildTemplateHash();
    if (cfg.installPath) {
      const targetRoot = path.resolve(cfg.installPath);
      targetDir = resolveTargetDir();
      installed = resourceHasManifest(targetDir);
      if (installed) {
        installedVersion = readInstalledVersion(targetDir);
        upToDate = installedVersion && installedVersion === templateVersion;
      }
      optionalMap = getOptionalMapStatus(targetRoot);
    }
  } catch (err) {
    error = err.message;
  }

  return {
    enabled: cfg.enabled,
    autoUpdate: cfg.autoUpdate,
    installPath: cfg.installPath,
    syncIntervalMinutes: cfg.syncIntervalMinutes,
    resourceName: RESOURCE_NAME,
    targetDir,
    installed,
    upToDate,
    installedVersion,
    templateVersion,
    optionalMap,
    error,
  };
}

function stopFiveMResourceAutoSync() {
  if (syncInterval) {
    clearInterval(syncInterval);
    syncInterval = null;
  }
}

function startFiveMResourceAutoSync() {
  stopFiveMResourceAutoSync();

  // Always deploy voice.cfg on startup if FIVEM_SERVER_PATH is set,
  // regardless of whether the full bridge auto-sync is enabled.
  deployVoiceCfg();

  const cfg = getConfig();
  if (!cfg.enabled || !cfg.autoUpdate || !cfg.installPath) return;

  const runSync = () => {
    try {
      // Keep voice.cfg in sync on every resource sync cycle
      deployVoiceCfg();

      const status = getStatus();
      const shouldSyncBridge = !status.installed || !status.upToDate;
      const shouldSyncOptionalMap = status.optionalMap?.available
        && (!status.optionalMap.installed || !status.optionalMap.upToDate);

      if (shouldSyncBridge || shouldSyncOptionalMap) {
        const result = installOrUpdateResource();
        console.log(`[FiveMBridge] Resource synced to ${result.targetDir}`);
        if (Array.isArray(result.resources)) {
          for (const resource of result.resources) {
            if (resource.resourceName === RESOURCE_NAME) continue;
            console.log(`[FiveMBridge] Resource synced to ${resource.targetDir}`);
          }
        }
      } else if (status.targetDir) {
        // Keep runtime token/base URL defaults in sync with CAD settings.
        applyRuntimeConfig(status.targetDir);
      }
    } catch (err) {
      console.error('[FiveMBridge] Auto-sync failed:', err.message);
    }
  };

  runSync();
  syncInterval = setInterval(runSync, cfg.syncIntervalMinutes * 60 * 1000);
  console.log(`[FiveMBridge] Auto-sync enabled (${cfg.syncIntervalMinutes} min)`);
}

module.exports = {
  RESOURCE_NAME,
  installOrUpdateResource,
  getStatus,
  startFiveMResourceAutoSync,
  stopFiveMResourceAutoSync,
  deployVoiceCfg,
};
