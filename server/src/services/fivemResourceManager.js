const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const { Settings } = require('../db/sqlite');

const RESOURCE_NAME = 'cad_bridge';
const RESOURCE_TEMPLATES = [
  {
    resourceName: 'cad_bridge',
    templateDir: path.resolve(__dirname, '../../fivem-resource'),
    versionFileName: '.cad_bridge_version',
    needsRuntimeConfig: true,
  },
];

let syncInterval = null;

function getSetting(key, fallback = '') {
  const value = Settings.get(key);
  if (value === undefined || value === null || value === '') return fallback;
  return String(value);
}

function normalizePath(input) {
  return String(input || '').trim().replace(/^"(.*)"$/, '$1');
}

function getConfig() {
  return {
    enabled: getSetting('fivem_bridge_enabled', 'false').toLowerCase() === 'true',
    autoUpdate: getSetting('fivem_bridge_auto_update', 'true').toLowerCase() === 'true',
    installPath: normalizePath(getSetting('fivem_bridge_install_path', '')),
    syncIntervalMinutes: Math.max(1, parseInt(getSetting('fivem_bridge_sync_interval_minutes', '5'), 10) || 5),
  };
}

function ensureTemplateExists(templateDir, resourceName) {
  if (!fs.existsSync(templateDir)) {
    throw new Error(`FiveM resource template not found for ${resourceName} at ${templateDir}`);
  }
  if (!fs.existsSync(path.join(templateDir, 'fxmanifest.lua'))) {
    throw new Error(`Invalid FiveM resource template for ${resourceName} (missing fxmanifest.lua)`);
  }
}

function resourceHasManifest(resourceDir) {
  if (!resourceDir || !fs.existsSync(resourceDir)) return false;
  return fs.existsSync(path.join(resourceDir, 'fxmanifest.lua'))
    || fs.existsSync(path.join(resourceDir, '__resource.lua'));
}

function listFilesRecursively(rootDir) {
  const files = [];

  function walk(current, prefix = '') {
    const entries = fs.readdirSync(current, { withFileTypes: true });
    for (const entry of entries) {
      const rel = prefix ? path.posix.join(prefix, entry.name) : entry.name;
      const abs = path.join(current, entry.name);
      if (entry.isDirectory()) {
        walk(abs, rel);
      } else if (entry.isFile()) {
        files.push({ rel, abs });
      }
    }
  }

  walk(rootDir);
  return files.sort((a, b) => a.rel.localeCompare(b.rel));
}

function buildTemplateHash(rootDir) {
  const hash = crypto.createHash('sha256');
  for (const file of listFilesRecursively(rootDir)) {
    hash.update(file.rel);
    hash.update(fs.readFileSync(file.abs));
  }
  return hash.digest('hex');
}

function resolveTargetDir(resourceName) {
  const { installPath } = getConfig();
  if (!installPath) throw new Error('fivem_bridge_install_path is not configured');
  return path.join(path.resolve(installPath), resourceName);
}

function escapeDoubleQuoted(value) {
  return String(value || '')
    .replace(/\\/g, '\\\\')
    .replace(/"/g, '\\"');
}

function upsertConfigEntry(content, key, value) {
  const line = `${key}="${escapeDoubleQuoted(value)}"`;
  const keyPattern = key.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const regex = new RegExp(`^\\s*(?:setr?\\s+|sets\\s+)?${keyPattern}(?:\\s*=\\s*|\\s+).*$`, 'im');

  if (regex.test(content)) {
    return content.replace(regex, line);
  }

  const normalized = content.replace(/\s*$/, '');
  if (!normalized) return `${line}\n`;
  return `${normalized}\n${line}\n`;
}

function applyCadBridgeRuntimeConfig(targetDir) {
  const configPath = path.join(targetDir, 'config.cfg');

  const bridgeHttpPort = parseInt(process.env.BRIDGE_HTTP_PORT || '3031', 10) || 3031;
  const baseUrl = getSetting('fivem_bridge_base_url', `http://127.0.0.1:${bridgeHttpPort}`);
  const token = getSetting('fivem_bridge_shared_token', '');

  let content = '';
  if (fs.existsSync(configPath)) {
    content = fs.readFileSync(configPath, 'utf8');
  } else {
    content = '# Auto-generated by CAD runtime sync.\n';
  }

  content = upsertConfigEntry(content, 'cad_bridge_base_url', baseUrl);
  content = upsertConfigEntry(content, 'cad_bridge_token', token);
  fs.writeFileSync(configPath, content, 'utf8');
}

function writeVersionFile(targetDir, version, fileName) {
  const content = JSON.stringify({ version, updated_at: new Date().toISOString() }, null, 2);
  fs.writeFileSync(path.join(targetDir, fileName), content, 'utf8');
}

function readInstalledVersion(targetDir, fileName) {
  const versionFile = path.join(targetDir, fileName);
  if (!fs.existsSync(versionFile)) return '';
  try {
    const parsed = JSON.parse(fs.readFileSync(versionFile, 'utf8'));
    return String(parsed.version || '');
  } catch {
    return '';
  }
}

function installOrUpdateResource() {
  const resources = [];

  for (const resource of RESOURCE_TEMPLATES) {
    ensureTemplateExists(resource.templateDir, resource.resourceName);
    const targetDir = resolveTargetDir(resource.resourceName);
    const version = buildTemplateHash(resource.templateDir);

    fs.mkdirSync(path.dirname(targetDir), { recursive: true });
    fs.mkdirSync(targetDir, { recursive: true });
    fs.cpSync(resource.templateDir, targetDir, { recursive: true, force: true });

    if (resource.needsRuntimeConfig) {
      applyCadBridgeRuntimeConfig(targetDir);
    }

    writeVersionFile(targetDir, version, resource.versionFileName);

    resources.push({
      resourceName: resource.resourceName,
      targetDir,
      version,
      installed: true,
      upToDate: true,
      installedVersion: version,
      templateVersion: version,
      error: '',
    });
  }

  const primary = resources.find(item => item.resourceName === RESOURCE_NAME) || resources[0];
  return {
    resourceName: RESOURCE_NAME,
    targetDir: primary?.targetDir || '',
    version: primary?.version || '',
    resources,
  };
}

function getStatus() {
  const cfg = getConfig();
  const resources = [];
  let combinedError = '';

  for (const resource of RESOURCE_TEMPLATES) {
    let installed = false;
    let upToDate = false;
    let installedVersion = '';
    let templateVersion = '';
    let targetDir = '';
    let error = '';

    try {
      ensureTemplateExists(resource.templateDir, resource.resourceName);
      templateVersion = buildTemplateHash(resource.templateDir);
      if (cfg.installPath) {
        targetDir = resolveTargetDir(resource.resourceName);
        installed = resourceHasManifest(targetDir);
        if (installed) {
          installedVersion = readInstalledVersion(targetDir, resource.versionFileName);
          upToDate = installedVersion && installedVersion === templateVersion;
        }
      }
    } catch (err) {
      error = err.message;
      if (!combinedError) combinedError = error;
    }

    resources.push({
      resourceName: resource.resourceName,
      targetDir,
      installed,
      upToDate,
      installedVersion,
      templateVersion,
      error,
    });
  }

  const primary = resources.find(item => item.resourceName === RESOURCE_NAME) || resources[0] || {};
  return {
    enabled: cfg.enabled,
    autoUpdate: cfg.autoUpdate,
    installPath: cfg.installPath,
    syncIntervalMinutes: cfg.syncIntervalMinutes,
    resourceName: RESOURCE_NAME,
    targetDir: primary.targetDir || '',
    installed: !!primary.installed,
    upToDate: !!primary.upToDate,
    installedVersion: primary.installedVersion || '',
    templateVersion: primary.templateVersion || '',
    resources,
    error: combinedError,
  };
}

function stopFiveMResourceAutoSync() {
  if (syncInterval) {
    clearInterval(syncInterval);
    syncInterval = null;
  }
}

function startFiveMResourceAutoSync() {
  stopFiveMResourceAutoSync();

  const cfg = getConfig();
  if (!cfg.enabled || !cfg.autoUpdate || !cfg.installPath) return;

  const runSync = () => {
    try {
      const status = getStatus();
      const resources = Array.isArray(status.resources) ? status.resources : [];
      const outOfDate = resources.some(item => !item.installed || !item.upToDate);

      if (outOfDate || resources.length === 0) {
        const result = installOrUpdateResource();
        const targets = (result.resources || []).map(item => item.targetDir).filter(Boolean);
        console.log(`[FiveMBridge] Resource sync complete: ${targets.join(', ') || result.targetDir}`);
      } else {
        const bridgeResource = resources.find(item => item.resourceName === RESOURCE_NAME);
        if (bridgeResource?.targetDir) {
          // Keep runtime token/base URL defaults in sync with CAD settings.
          applyCadBridgeRuntimeConfig(bridgeResource.targetDir);
        }
      }
    } catch (err) {
      console.error('[FiveMBridge] Auto-sync failed:', err.message);
    }
  };

  runSync();
  syncInterval = setInterval(runSync, cfg.syncIntervalMinutes * 60 * 1000);
  console.log(`[FiveMBridge] Auto-sync enabled (${cfg.syncIntervalMinutes} min)`);
}

module.exports = {
  RESOURCE_NAME,
  installOrUpdateResource,
  getStatus,
  startFiveMResourceAutoSync,
  stopFiveMResourceAutoSync,
};
