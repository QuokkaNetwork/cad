const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const { Settings } = require('../db/sqlite');

const RESOURCE_NAME = 'cad_bridge';

function deployVoiceCfg() {
  // Intentionally disabled: CAD no longer writes/deploys voice.cfg.
  // Manage native FiveM voice settings directly in your FiveM server.cfg.
}

const TEMPLATE_DIR = path.resolve(__dirname, '../../fivem-resource');
const VERSION_FILE_NAME = '.cad_bridge_version';
const OPTIONAL_MAP_RESOURCE_NAME = 'map';
const OPTIONAL_MAP_TEMPLATE_DIR = path.resolve(__dirname, '../../../map');
const OPTIONAL_MAP_VERSION_FILE_NAME = '.cad_map_version';
let syncInterval = null;

function getSetting(key, fallback = '') {
  const value = Settings.get(key);
  if (value === undefined || value === null || value === '') return fallback;
  return String(value);
}

function normalizePath(input) {
  return String(input || '').trim().replace(/^"(.*)"$/, '$1');
}

function getConfig() {
  return {
    enabled: getSetting('fivem_bridge_enabled', 'false').toLowerCase() === 'true',
    autoUpdate: getSetting('fivem_bridge_auto_update', 'true').toLowerCase() === 'true',
    installPath: normalizePath(getSetting('fivem_bridge_install_path', '')),
    syncIntervalMinutes: Math.max(1, parseInt(getSetting('fivem_bridge_sync_interval_minutes', '5'), 10) || 5),
  };
}

function ensureTemplateExists() {
  if (!fs.existsSync(TEMPLATE_DIR)) {
    throw new Error(`FiveM resource template not found at ${TEMPLATE_DIR}`);
  }
  if (!fs.existsSync(path.join(TEMPLATE_DIR, 'fxmanifest.lua'))) {
    throw new Error('Invalid FiveM resource template (missing fxmanifest.lua)');
  }
}

function resourceHasManifest(resourceDir) {
  if (!resourceDir || !fs.existsSync(resourceDir)) return false;
  return fs.existsSync(path.join(resourceDir, 'fxmanifest.lua'))
    || fs.existsSync(path.join(resourceDir, '__resource.lua'));
}

function listFilesRecursively(rootDir) {
  const files = [];
  function walk(current, prefix = '') {
    const entries = fs.readdirSync(current, { withFileTypes: true });
    for (const entry of entries) {
      const rel = prefix ? path.posix.join(prefix, entry.name) : entry.name;
      const abs = path.join(current, entry.name);
      if (entry.isDirectory()) {
        walk(abs, rel);
      } else if (entry.isFile()) {
        files.push({ rel, abs });
      }
    }
  }
  walk(rootDir);
  return files.sort((a, b) => a.rel.localeCompare(b.rel));
}

function buildTemplateHash(rootDir = TEMPLATE_DIR) {
  const hash = crypto.createHash('sha256');
  for (const file of listFilesRecursively(rootDir)) {
    hash.update(file.rel);
    hash.update(fs.readFileSync(file.abs));
  }
  return hash.digest('hex');
}

function resolveTargetDir() {
  const { installPath } = getConfig();
  if (!installPath) throw new Error('fivem_bridge_install_path is not configured');
  return path.join(path.resolve(installPath), RESOURCE_NAME);
}

function escapeDoubleQuoted(value) {
  return String(value || '')
    .replace(/\\/g, '\\\\')
    .replace(/"/g, '\\"');
}

function upsertConfigEntry(content, key, value) {
  const line = `${key}="${escapeDoubleQuoted(value)}"`;
  const keyPattern = key.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const regex = new RegExp(`^\\s*(?:setr?\\s+|sets\\s+)?${keyPattern}(?:\\s*=\\s*|\\s+).*$`, 'im');

  if (regex.test(content)) {
    return content.replace(regex, line);
  }

  const normalized = content.replace(/\s*$/, '');
  if (!normalized) return `${line}\n`;
  return `${normalized}\n${line}\n`;
}

function applyRuntimeConfig(targetDir) {
  const configPath = path.join(targetDir, 'config.cfg');

  const _bridgeHttpPort = parseInt(process.env.BRIDGE_HTTP_PORT || '3031', 10) || 3031;
  const baseUrl = getSetting('fivem_bridge_base_url', `http://127.0.0.1:${_bridgeHttpPort}`);
  const token = getSetting('fivem_bridge_shared_token', '');

  let content = '';
  if (fs.existsSync(configPath)) {
    content = fs.readFileSync(configPath, 'utf8');
  } else {
    content = '# Auto-generated by CAD runtime sync.\n';
  }

  content = upsertConfigEntry(content, 'cad_bridge_base_url', baseUrl);
  content = upsertConfigEntry(content, 'cad_bridge_token', token);

  fs.writeFileSync(configPath, content, 'utf8');
}

function writeVersionFile(targetDir, version, fileName = VERSION_FILE_NAME) {
  const content = JSON.stringify({ version, updated_at: new Date().toISOString() }, null, 2);
  fs.writeFileSync(path.join(targetDir, fileName), content, 'utf8');
}

function readInstalledVersion(targetDir, fileName = VERSION_FILE_NAME) {
  const versionFile = path.join(targetDir, fileName);
  if (!fs.existsSync(versionFile)) return '';
  try {
    const parsed = JSON.parse(fs.readFileSync(versionFile, 'utf8'));
    return String(parsed.version || '');
  } catch {
    return '';
  }
}

function getOptionalMapStatus(targetRoot = '') {
  const available = resourceHasManifest(OPTIONAL_MAP_TEMPLATE_DIR);
  const targetDir = targetRoot ? path.join(targetRoot, OPTIONAL_MAP_RESOURCE_NAME) : '';

  const status = {
    resourceName: OPTIONAL_MAP_RESOURCE_NAME,
    available,
    targetDir,
    installed: false,
    upToDate: false,
    installedVersion: '',
    templateVersion: '',
  };

  if (!available || !targetRoot) return status;

  status.templateVersion = buildTemplateHash(OPTIONAL_MAP_TEMPLATE_DIR);
  status.installed = resourceHasManifest(targetDir);
  if (status.installed) {
    status.installedVersion = readInstalledVersion(targetDir, OPTIONAL_MAP_VERSION_FILE_NAME);
    status.upToDate = Boolean(status.installedVersion && status.installedVersion === status.templateVersion);
  }

  return status;
}

function installOrUpdateOptionalMapResource(targetRoot) {
  const status = getOptionalMapStatus(targetRoot);
  if (!status.available || !status.targetDir || !status.templateVersion) return null;

  if (!status.installed || !status.upToDate) {
    fs.mkdirSync(status.targetDir, { recursive: true });
    fs.cpSync(OPTIONAL_MAP_TEMPLATE_DIR, status.targetDir, { recursive: true, force: true });
    writeVersionFile(status.targetDir, status.templateVersion, OPTIONAL_MAP_VERSION_FILE_NAME);
  }

  return {
    resourceName: OPTIONAL_MAP_RESOURCE_NAME,
    targetDir: status.targetDir,
    version: status.templateVersion,
    installed: true,
    upToDate: true,
  };
}

function installOrUpdateResource() {
  ensureTemplateExists();
  const targetDir = resolveTargetDir();
  const targetRoot = path.dirname(targetDir);
  const version = buildTemplateHash();

  fs.mkdirSync(targetRoot, { recursive: true });
  fs.mkdirSync(targetDir, { recursive: true });

  fs.cpSync(TEMPLATE_DIR, targetDir, { recursive: true, force: true });
  applyRuntimeConfig(targetDir);
  writeVersionFile(targetDir, version);

  const resources = [{
    resourceName: RESOURCE_NAME,
    targetDir,
    version,
    installed: true,
    upToDate: true,
  }];
  const optionalMap = installOrUpdateOptionalMapResource(targetRoot);
  if (optionalMap) resources.push(optionalMap);

  return {
    resourceName: RESOURCE_NAME,
    targetDir,
    version,
    resources,
  };
}

function getStatus() {
  const cfg = getConfig();
  let installed = false;
  let upToDate = false;
  let installedVersion = '';
  let templateVersion = '';
  let targetDir = '';
  let optionalMap = getOptionalMapStatus('');
  let error = '';

  try {
    ensureTemplateExists();
    templateVersion = buildTemplateHash();
    if (cfg.installPath) {
      const targetRoot = path.resolve(cfg.installPath);
      targetDir = resolveTargetDir();
      installed = resourceHasManifest(targetDir);
      if (installed) {
        installedVersion = readInstalledVersion(targetDir);
        upToDate = installedVersion && installedVersion === templateVersion;
      }
      optionalMap = getOptionalMapStatus(targetRoot);
    }
  } catch (err) {
    error = err.message;
  }

  return {
    enabled: cfg.enabled,
    autoUpdate: cfg.autoUpdate,
    installPath: cfg.installPath,
    syncIntervalMinutes: cfg.syncIntervalMinutes,
    resourceName: RESOURCE_NAME,
    targetDir,
    installed,
    upToDate,
    installedVersion,
    templateVersion,
    optionalMap,
    error,
  };
}

function stopFiveMResourceAutoSync() {
  if (syncInterval) {
    clearInterval(syncInterval);
    syncInterval = null;
  }
}

function startFiveMResourceAutoSync() {
  stopFiveMResourceAutoSync();

  const cfg = getConfig();
  if (!cfg.enabled || !cfg.autoUpdate || !cfg.installPath) return;

  const runSync = () => {
    try {
      const status = getStatus();
      const shouldSyncBridge = !status.installed || !status.upToDate;
      const shouldSyncOptionalMap = status.optionalMap?.available
        && (!status.optionalMap.installed || !status.optionalMap.upToDate);

      if (shouldSyncBridge || shouldSyncOptionalMap) {
        const result = installOrUpdateResource();
        console.log(`[FiveMBridge] Resource synced to ${result.targetDir}`);
        if (Array.isArray(result.resources)) {
          for (const resource of result.resources) {
            if (resource.resourceName === RESOURCE_NAME) continue;
            console.log(`[FiveMBridge] Resource synced to ${resource.targetDir}`);
          }
        }
      } else if (status.targetDir) {
        // Keep runtime token/base URL defaults in sync with CAD settings.
        applyRuntimeConfig(status.targetDir);
      }
    } catch (err) {
      console.error('[FiveMBridge] Auto-sync failed:', err.message);
    }
  };

  runSync();
  syncInterval = setInterval(runSync, cfg.syncIntervalMinutes * 60 * 1000);
  console.log(`[FiveMBridge] Auto-sync enabled (${cfg.syncIntervalMinutes} min)`);
}

module.exports = {
  RESOURCE_NAME,
  installOrUpdateResource,
  getStatus,
  startFiveMResourceAutoSync,
  stopFiveMResourceAutoSync,
  deployVoiceCfg,
};
