const express = require('express');
const fs = require('fs');
const path = require('path');
const multer = require('multer');
const sharp = require('sharp');
const { requireAuth, requireAdmin } = require('../auth/middleware');
const {
  Users, Departments, UserDepartments, DiscordRoleMappings,
  Settings, AuditLog, Announcements, Units, FiveMPlayerLinks, FiveMFineJobs, FiveMJobSyncJobs, SubDepartments, OffenceCatalog,
} = require('../db/sqlite');
const { audit } = require('../utils/audit');
const bus = require('../utils/eventBus');
const qbox = require('../db/qbox');
const { processPendingFineJobs } = require('../services/fivemFineProcessor');
const {
  installOrUpdateResource,
  getStatus: getFiveMResourceStatus,
  startFiveMResourceAutoSync,
} = require('../services/fivemResourceManager');

const router = express.Router();
router.use(requireAuth, requireAdmin);
const ACTIVE_LINK_MAX_AGE_MS = 5 * 60 * 1000;
const OFFENCE_CATEGORIES = new Set(['infringement', 'summary', 'indictment']);

function parseSqliteUtc(value) {
  const text = String(value || '').trim();
  if (!text) return NaN;
  const base = text.replace(' ', 'T');
  const normalized = base.endsWith('Z') ? base : `${base}Z`;
  return Date.parse(normalized);
}

function isActiveFiveMLink(link) {
  const ts = parseSqliteUtc(link?.updated_at);
  if (Number.isNaN(ts)) return false;
  return (Date.now() - ts) <= ACTIVE_LINK_MAX_AGE_MS;
}

function parseFiveMLinkKey(value) {
  const key = String(value || '').trim();
  if (!key) return { type: 'unknown', value: '' };
  if (key.startsWith('discord:')) {
    return { type: 'discord', value: key.slice('discord:'.length) };
  }
  if (key.startsWith('license:')) {
    return { type: 'license', value: key.slice('license:'.length) };
  }
  return { type: 'steam', value: key };
}

function normalizeOffenceCategory(value) {
  const normalized = String(value || '').trim().toLowerCase();
  if (OFFENCE_CATEGORIES.has(normalized)) return normalized;
  return 'infringement';
}

function parseOrderedIds(value) {
  if (!Array.isArray(value)) return [];
  return Array.from(new Set(
    value
      .map(id => Number(id))
      .filter(id => Number.isInteger(id) && id > 0)
  ));
}

const uploadRoot = path.resolve(__dirname, '../../data/uploads/department-icons');
fs.mkdirSync(uploadRoot, { recursive: true });

const upload = multer({
  storage: multer.memoryStorage(),
  limits: { fileSize: 2 * 1024 * 1024 },
  fileFilter: (_req, file, cb) => {
    const allowed = new Set(['image/png', 'image/jpeg', 'image/webp', 'image/gif']);
    if (allowed.has(file.mimetype)) return cb(null, true);
    cb(new Error('Only PNG, JPG, WEBP, or GIF images are allowed'));
  },
});

router.post('/departments/upload-icon', upload.single('icon'), async (req, res, next) => {
  if (!req.file) return res.status(400).json({ error: 'icon file is required' });
  try {
    const fileName = `${Date.now()}-${Math.random().toString(36).slice(2, 10)}.webp`;
    const outputPath = path.join(uploadRoot, fileName);

    await sharp(req.file.buffer)
      .rotate()
      .resize(256, 256, {
        fit: 'contain',
        background: { r: 0, g: 0, b: 0, alpha: 0 },
      })
      .webp({ quality: 88 })
      .toFile(outputPath);

    res.json({ icon: `/uploads/department-icons/${fileName}` });
  } catch (err) {
    next(err);
  }
});

// --- Users ---
router.get('/users', (req, res) => {
  const users = Users.list().map(u => {
    u.departments = UserDepartments.getForUser(u.id);
    return u;
  });
  res.json(users);
});

router.patch('/users/:id', (req, res) => {
  const userId = parseInt(req.params.id, 10);
  const user = Users.findById(userId);
  if (!user) return res.status(404).json({ error: 'User not found' });

  const { is_admin, is_banned, preferred_citizen_id } = req.body;
  const updates = {};
  if (is_admin !== undefined) updates.is_admin = is_admin ? 1 : 0;
  if (is_banned !== undefined) updates.is_banned = is_banned ? 1 : 0;
  if (preferred_citizen_id !== undefined) updates.preferred_citizen_id = String(preferred_citizen_id || '').trim();

  Users.update(userId, updates);
  audit(req.user.id, 'user_updated', { targetUserId: userId, updates });

  if (is_banned) {
    Units.removeByUserId(userId);
  }

  if (preferred_citizen_id !== undefined) {
    try {
      const { queueJobSyncForUserId } = require('../discord/bot');
      const queued = queueJobSyncForUserId(userId);
      if (queued) {
        audit(req.user.id, 'user_character_linked', {
          targetUserId: userId,
          preferred_citizen_id: String(preferred_citizen_id || '').trim(),
          jobSyncJobId: queued.id,
        });
      }
    } catch (err) {
      console.warn('[Admin] Could not queue job sync for character link update:', err?.message || err);
    }
  }

  res.json(Users.findById(userId));
});

// --- Departments ---
router.get('/departments', (req, res) => {
  const depts = Departments.list();
  const allSubs = SubDepartments.list();
  const withCounts = depts.map(d => ({
    ...d,
    sub_department_count: allSubs.filter(sd => sd.department_id === d.id).length,
  }));
  res.json(withCounts);
});

router.post('/departments', (req, res) => {
  const {
    name,
    short_name,
    color,
    icon,
    layout_type,
    fivem_job_name,
    fivem_job_grade,
  } = req.body;
  if (!name) return res.status(400).json({ error: 'name is required' });

  const dept = Departments.create({
    name,
    short_name,
    color,
    icon,
    layout_type,
    fivem_job_name: String(fivem_job_name || '').trim(),
    fivem_job_grade: Number.isFinite(Number(fivem_job_grade)) ? Number(fivem_job_grade) : 0,
  });
  audit(req.user.id, 'department_created', { departmentId: dept.id, name });
  res.status(201).json(dept);
});

router.patch('/departments/:id', (req, res) => {
  const id = parseInt(req.params.id, 10);
  const dept = Departments.findById(id);
  if (!dept) return res.status(404).json({ error: 'Department not found' });

  Departments.update(id, req.body);
  audit(req.user.id, 'department_updated', { departmentId: id });
  res.json(Departments.findById(id));
});

router.post('/departments/reorder', (req, res) => {
  const orderedIds = parseOrderedIds(req.body?.ordered_ids);
  if (!orderedIds.length) {
    return res.status(400).json({ error: 'ordered_ids is required' });
  }

  const departments = Departments.list();
  const existingIds = new Set(departments.map(d => d.id));
  if (orderedIds.some(id => !existingIds.has(id))) {
    return res.status(400).json({ error: 'ordered_ids contains unknown department id(s)' });
  }

  const provided = new Set(orderedIds);
  const remaining = departments
    .filter(d => !provided.has(d.id))
    .map(d => d.id);
  const finalOrder = [...orderedIds, ...remaining];

  Departments.reorder(finalOrder);
  audit(req.user.id, 'department_reordered', { ordered_ids: finalOrder });
  res.json(Departments.list());
});

router.delete('/departments/:id', (req, res) => {
  const id = parseInt(req.params.id, 10);
  const dept = Departments.findById(id);
  if (!dept) return res.status(404).json({ error: 'Department not found' });
  try {
    Departments.delete(id);
    audit(req.user.id, 'department_deleted', { departmentId: id });
    res.json({ success: true });
  } catch (err) {
    if (String(err.message).includes('FOREIGN KEY')) {
      return res.status(400).json({ error: 'Cannot delete department while records/units/mappings still reference it' });
    }
    throw err;
  }
});

// --- Sub Departments ---
router.get('/sub-departments', (req, res) => {
  const deptId = parseInt(req.query.department_id, 10);
  if (deptId) {
    return res.json(SubDepartments.listByDepartment(deptId));
  }
  res.json(SubDepartments.list());
});

router.post('/sub-departments', (req, res) => {
  const {
    department_id,
    name,
    short_name,
    color,
    is_active,
    fivem_job_name,
    fivem_job_grade,
  } = req.body;
  const deptId = parseInt(department_id, 10);
  if (!deptId || !name || !short_name) {
    return res.status(400).json({ error: 'department_id, name and short_name are required' });
  }
  const parent = Departments.findById(deptId);
  if (!parent) return res.status(400).json({ error: 'Parent department not found' });

  try {
    const sub = SubDepartments.create({
      department_id: deptId,
      name: String(name).trim(),
      short_name: String(short_name).trim(),
      color: color || parent.color || '#0052C2',
      is_active: is_active === undefined ? 1 : (is_active ? 1 : 0),
      fivem_job_name: String(fivem_job_name || '').trim(),
      fivem_job_grade: Number.isFinite(Number(fivem_job_grade)) ? Number(fivem_job_grade) : 0,
    });
    audit(req.user.id, 'sub_department_created', { subDepartmentId: sub.id, departmentId: deptId });
    res.status(201).json(sub);
  } catch (err) {
    if (String(err.message).includes('UNIQUE')) {
      return res.status(400).json({ error: 'Sub-department name or short name already exists for this department' });
    }
    throw err;
  }
});

router.patch('/sub-departments/:id', (req, res) => {
  const id = parseInt(req.params.id, 10);
  const sub = SubDepartments.findById(id);
  if (!sub) return res.status(404).json({ error: 'Sub department not found' });

  try {
    SubDepartments.update(id, req.body || {});
    audit(req.user.id, 'sub_department_updated', { subDepartmentId: id });
    res.json(SubDepartments.findById(id));
  } catch (err) {
    if (String(err.message).includes('UNIQUE')) {
      return res.status(400).json({ error: 'Sub-department name or short name already exists for this department' });
    }
    throw err;
  }
});

router.post('/sub-departments/reorder', (req, res) => {
  const departmentId = parseInt(req.body?.department_id, 10);
  if (!departmentId) return res.status(400).json({ error: 'department_id is required' });
  if (!Departments.findById(departmentId)) return res.status(404).json({ error: 'Department not found' });

  const orderedIds = parseOrderedIds(req.body?.ordered_ids);
  if (!orderedIds.length) return res.status(400).json({ error: 'ordered_ids is required' });

  const subs = SubDepartments.listByDepartment(departmentId);
  const existingIds = new Set(subs.map(s => s.id));
  if (orderedIds.some(id => !existingIds.has(id))) {
    return res.status(400).json({ error: 'ordered_ids contains unknown sub-department id(s) for that department' });
  }

  const provided = new Set(orderedIds);
  const remaining = subs.filter(s => !provided.has(s.id)).map(s => s.id);
  const finalOrder = [...orderedIds, ...remaining];

  SubDepartments.reorderForDepartment(departmentId, finalOrder);
  audit(req.user.id, 'sub_department_reordered', { departmentId, ordered_ids: finalOrder });
  res.json(SubDepartments.listByDepartment(departmentId));
});

router.delete('/sub-departments/:id', (req, res) => {
  const id = parseInt(req.params.id, 10);
  const sub = SubDepartments.findById(id);
  if (!sub) return res.status(404).json({ error: 'Sub department not found' });
  try {
    SubDepartments.delete(id);
    audit(req.user.id, 'sub_department_deleted', { subDepartmentId: id });
    res.json({ success: true });
  } catch (err) {
    if (String(err.message).includes('FOREIGN KEY')) {
      return res.status(400).json({ error: 'Cannot delete sub department while units still reference it' });
    }
    throw err;
  }
});

// --- Discord Role Mappings ---
router.get('/role-mappings', (req, res) => {
  res.json(DiscordRoleMappings.list());
});

router.post('/role-mappings', (req, res) => {
  const { discord_role_id, discord_role_name, target_type, target_id, department_id } = req.body;

  // Backward compatibility: treat department_id as department target.
  const resolvedType = target_type || (department_id ? 'department' : '');
  const resolvedTargetId = parseInt(target_id || department_id, 10);
  if (!discord_role_id || !resolvedType || !resolvedTargetId) {
    return res.status(400).json({ error: 'discord_role_id, target_type and target_id are required' });
  }
  if (!['department', 'sub_department'].includes(resolvedType)) {
    return res.status(400).json({ error: 'target_type must be department or sub_department' });
  }
  if (resolvedType === 'department' && !Departments.findById(resolvedTargetId)) {
    return res.status(400).json({ error: 'Department target not found' });
  }
  if (resolvedType === 'sub_department' && !SubDepartments.findById(resolvedTargetId)) {
    return res.status(400).json({ error: 'Sub-department target not found' });
  }

  try {
    const mapping = DiscordRoleMappings.create({
      discord_role_id,
      discord_role_name: discord_role_name || '',
      target_type: resolvedType,
      target_id: resolvedTargetId,
    });
    audit(req.user.id, 'role_mapping_created', { mapping });
    res.status(201).json(mapping);
  } catch (err) {
    if (err.message.includes('UNIQUE')) {
      return res.status(400).json({ error: 'This Discord role is already mapped to that target' });
    }
    throw err;
  }
});

router.delete('/role-mappings/:id', (req, res) => {
  const id = parseInt(req.params.id, 10);
  DiscordRoleMappings.delete(id);
  audit(req.user.id, 'role_mapping_deleted', { mappingId: id });
  res.json({ success: true });
});

// Discord guild roles (from bot)
router.get('/discord/roles', async (req, res) => {
  try {
    const { getGuildRoles } = require('../discord/bot');
    const roles = await getGuildRoles();
    res.json(roles);
  } catch (err) {
    res.status(500).json({ error: 'Could not fetch Discord roles', message: err.message });
  }
});

// Trigger full role sync
router.post('/discord/sync', async (req, res) => {
  try {
    const { syncAllMembers } = require('../discord/bot');
    const result = await syncAllMembers();
    audit(req.user.id, 'discord_full_sync', result);
    res.json(result);
  } catch (err) {
    res.status(500).json({ error: 'Sync failed', message: err.message });
  }
});

// --- QBox diagnostics ---
router.get('/qbox/test', async (req, res) => {
  try {
    const result = await qbox.testConnection();
    if (!result.success) {
      return res.status(400).json({ error: 'QBox connection failed', message: result.message });
    }
    res.json(result);
  } catch (err) {
    res.status(500).json({ error: 'QBox connection failed', message: err.message });
  }
});

router.get('/qbox/schema', async (req, res) => {
  try {
    const report = await qbox.inspectConfiguredSchema();
    if (!report.success) {
      return res.status(400).json({ error: 'QBox schema validation failed', message: report.message, details: report });
    }
    res.json(report);
  } catch (err) {
    res.status(500).json({ error: 'QBox schema validation failed', message: err.message });
  }
});

// --- Offence catalog ---
router.get('/offence-catalog', (req, res) => {
  const includeInactive = String(req.query.include_inactive || '').toLowerCase() === 'true';
  const offences = OffenceCatalog.list(!includeInactive);
  res.json(offences);
});

router.post('/offence-catalog', (req, res) => {
  const {
    category,
    code,
    title,
    description,
    fine_amount,
    sort_order,
    is_active,
  } = req.body || {};

  const normalizedTitle = String(title || '').trim();
  if (!normalizedTitle) {
    return res.status(400).json({ error: 'title is required' });
  }

  const fineAmount = Number(fine_amount || 0);
  if (!Number.isFinite(fineAmount) || fineAmount < 0) {
    return res.status(400).json({ error: 'fine_amount must be a non-negative number' });
  }

  try {
    const offence = OffenceCatalog.create({
      category: normalizeOffenceCategory(category),
      code: String(code || '').trim(),
      title: normalizedTitle,
      description: String(description || '').trim(),
      fine_amount: fineAmount,
      sort_order: Number.isFinite(Number(sort_order)) ? Number(sort_order) : 0,
      is_active: is_active === undefined ? 1 : (is_active ? 1 : 0),
    });
    audit(req.user.id, 'offence_catalog_created', { offenceId: offence.id, category: offence.category });
    res.status(201).json(offence);
  } catch (err) {
    if (String(err?.message || '').includes('UNIQUE')) {
      return res.status(400).json({ error: 'An offence with that category/code already exists' });
    }
    throw err;
  }
});

router.patch('/offence-catalog/:id', (req, res) => {
  const id = parseInt(req.params.id, 10);
  if (!id) return res.status(400).json({ error: 'Invalid offence id' });
  const existing = OffenceCatalog.findById(id);
  if (!existing) return res.status(404).json({ error: 'Offence not found' });

  const updates = {};
  if (req.body?.category !== undefined) updates.category = normalizeOffenceCategory(req.body.category);
  if (req.body?.code !== undefined) updates.code = String(req.body.code || '').trim();
  if (req.body?.title !== undefined) {
    const normalizedTitle = String(req.body.title || '').trim();
    if (!normalizedTitle) return res.status(400).json({ error: 'title is required' });
    updates.title = normalizedTitle;
  }
  if (req.body?.description !== undefined) updates.description = String(req.body.description || '').trim();
  if (req.body?.sort_order !== undefined) updates.sort_order = Number.isFinite(Number(req.body.sort_order)) ? Number(req.body.sort_order) : 0;
  if (req.body?.is_active !== undefined) updates.is_active = req.body.is_active ? 1 : 0;
  if (req.body?.fine_amount !== undefined) {
    const fineAmount = Number(req.body.fine_amount);
    if (!Number.isFinite(fineAmount) || fineAmount < 0) {
      return res.status(400).json({ error: 'fine_amount must be a non-negative number' });
    }
    updates.fine_amount = fineAmount;
  }

  if (Object.keys(updates).length === 0) {
    return res.status(400).json({ error: 'No valid fields supplied' });
  }

  try {
    OffenceCatalog.update(id, updates);
    const updated = OffenceCatalog.findById(id);
    audit(req.user.id, 'offence_catalog_updated', { offenceId: id, updates: Object.keys(updates) });
    res.json(updated);
  } catch (err) {
    if (String(err?.message || '').includes('UNIQUE')) {
      return res.status(400).json({ error: 'An offence with that category/code already exists' });
    }
    throw err;
  }
});

router.delete('/offence-catalog/:id', (req, res) => {
  const id = parseInt(req.params.id, 10);
  if (!id) return res.status(400).json({ error: 'Invalid offence id' });
  const existing = OffenceCatalog.findById(id);
  if (!existing) return res.status(404).json({ error: 'Offence not found' });
  OffenceCatalog.delete(id);
  audit(req.user.id, 'offence_catalog_deleted', { offenceId: id });
  res.json({ success: true });
});

// --- Settings ---
router.get('/settings', (req, res) => {
  res.json(Settings.getAll());
});

router.put('/settings', (req, res) => {
  const { settings } = req.body;
  if (!settings || typeof settings !== 'object') {
    return res.status(400).json({ error: 'settings object is required' });
  }
  for (const [key, value] of Object.entries(settings)) {
    Settings.set(key, String(value));
  }
  startFiveMResourceAutoSync();
  audit(req.user.id, 'settings_updated', { keys: Object.keys(settings) });
  res.json(Settings.getAll());
});

// --- FiveM resource management ---
router.get('/fivem-resource/status', (_req, res) => {
  res.json(getFiveMResourceStatus());
});

router.post('/fivem-resource/install', (req, res) => {
  try {
    const result = installOrUpdateResource();
    audit(req.user.id, 'fivem_resource_installed', {
      targetDir: result.targetDir,
      version: result.version,
    });
    startFiveMResourceAutoSync();
    res.json({ success: true, ...result });
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
});

router.get('/fivem/links', (_req, res) => {
  const activeOnly = String(_req.query.active || '').toLowerCase() === 'true';
  const links = FiveMPlayerLinks.list();
  const filtered = activeOnly ? links.filter(isActiveFiveMLink) : links;
  const enriched = filtered.map((link) => {
    const parsed = parseFiveMLinkKey(link.steam_id);
    const cadUser = parsed.type === 'discord'
      ? (Users.findByDiscordId(parsed.value) || null)
      : (parsed.type === 'steam' ? (Users.findBySteamId(parsed.value) || null) : null);
    return {
      ...link,
      identifier_type: parsed.type,
      steam_id_resolved: parsed.type === 'steam' ? parsed.value : '',
      discord_id_resolved: parsed.type === 'discord' ? parsed.value : (cadUser?.discord_id || ''),
      license_id_resolved: parsed.type === 'license' ? parsed.value : '',
      cad_user_id: cadUser?.id || null,
      cad_user_name: cadUser?.steam_name || '',
    };
  });
  res.json(enriched);
});

router.get('/fivem/fine-jobs', (req, res) => {
  const limit = Math.min(500, Math.max(1, parseInt(req.query.limit, 10) || 100));
  res.json(FiveMFineJobs.listRecent(limit));
});

router.post('/fivem/fine-jobs/:id/retry', (req, res) => {
  const id = parseInt(req.params.id, 10);
  if (!id) return res.status(400).json({ error: 'Invalid job id' });
  const job = FiveMFineJobs.findById(id);
  if (!job) return res.status(404).json({ error: 'Fine job not found' });

  FiveMFineJobs.markPending(id);
  processPendingFineJobs().catch((err) => {
    console.error('[FineProcessor] Retry run failed:', err?.message || err);
  });
  res.json({ ok: true });
});

router.post('/fivem/fine-jobs/:id/cancel', (req, res) => {
  const id = parseInt(req.params.id, 10);
  if (!id) return res.status(400).json({ error: 'Invalid job id' });
  const job = FiveMFineJobs.findById(id);
  if (!job) return res.status(404).json({ error: 'Fine job not found' });

  FiveMFineJobs.markCancelled(id, 'Cancelled by admin');
  audit(req.user.id, 'fivem_fine_job_cancelled', { fineJobId: id });
  res.json({ ok: true });
});

router.post('/fivem/fine-jobs/clear-test', (req, res) => {
  const cleared = FiveMFineJobs.cancelPendingTestJobs('Cleared queued test fine jobs by admin');
  audit(req.user.id, 'fivem_test_fines_cleared', { cleared });
  res.json({ ok: true, cleared });
});

router.get('/fivem/job-sync-jobs', (req, res) => {
  const limit = Math.min(500, Math.max(1, parseInt(req.query.limit, 10) || 100));
  const jobs = FiveMJobSyncJobs.listRecent(limit).map((job) => {
    const user = Users.findById(job.user_id);
    return {
      ...job,
      cad_user_name: user?.steam_name || '',
      cad_discord_id: user?.discord_id || '',
    };
  });
  res.json(jobs);
});

router.post('/fivem/job-sync-jobs/:id/retry', (req, res) => {
  const id = parseInt(req.params.id, 10);
  if (!id) return res.status(400).json({ error: 'Invalid job sync id' });
  const job = FiveMJobSyncJobs.findById(id);
  if (!job) return res.status(404).json({ error: 'Job sync not found' });

  FiveMJobSyncJobs.markPending(id);
  res.json({ ok: true });
});

router.post('/fivem/test-fine', (req, res) => {
  const { steam_id, citizen_id, amount, reason } = req.body || {};
  const fineAmount = Number(amount);
  if (!Number.isFinite(fineAmount) || fineAmount <= 0) {
    return res.status(400).json({ error: 'amount must be a positive number' });
  }

  let link = null;
  if (steam_id) {
    link = FiveMPlayerLinks.findBySteamId(String(steam_id));
  } else if (citizen_id) {
    link = FiveMPlayerLinks.findByCitizenId(String(citizen_id));
  }

  if (!link) {
    return res.status(404).json({ error: 'Player not found in active FiveM links' });
  }
  if (!isActiveFiveMLink(link)) {
    return res.status(400).json({ error: 'Player is not currently detected in server' });
  }
  if (!String(link.citizen_id || '').trim()) {
    return res.status(400).json({ error: 'Selected player has no citizen_id available for fines' });
  }

  const jobReason = String(reason || 'CAD admin test fine').trim() || 'CAD admin test fine';
  const job = FiveMFineJobs.create({
    citizen_id: String(link.citizen_id),
    amount: fineAmount,
    reason: jobReason,
    issued_by_user_id: req.user.id,
    source_record_id: null,
  });
  processPendingFineJobs().catch((err) => {
    console.error('[FineProcessor] Immediate test fine run failed:', err?.message || err);
  });

  audit(req.user.id, 'fivem_test_fine_queued', {
    fineJobId: job.id,
    steam_id: link.steam_id,
    game_id: link.game_id,
    citizen_id: link.citizen_id,
    amount: fineAmount,
    reason: jobReason,
  });

  const deliveryMode = String(Settings.get('fivem_bridge_qbox_fines_delivery_mode') || 'bridge').trim().toLowerCase();
  res.status(201).json({ success: true, job, player: link, delivery_mode: deliveryMode });
});

// --- Audit Log ---
router.get('/audit-log', (req, res) => {
  const limit = parseInt(req.query.limit, 10) || 100;
  const offset = parseInt(req.query.offset, 10) || 0;
  res.json(AuditLog.list(limit, offset));
});

// --- Announcements ---
router.get('/announcements', (req, res) => {
  res.json(Announcements.list());
});

router.post('/announcements', (req, res) => {
  const { title, content, expires_at } = req.body;
  if (!title) return res.status(400).json({ error: 'title is required' });

  const announcement = Announcements.create({
    title,
    content: content || '',
    created_by: req.user.id,
    expires_at: expires_at || null,
  });

  bus.emit('announcement:new', { announcement });
  audit(req.user.id, 'announcement_created', { announcementId: announcement.id });
  res.status(201).json(announcement);
});

router.delete('/announcements/:id', (req, res) => {
  const id = parseInt(req.params.id, 10);
  Announcements.delete(id);
  audit(req.user.id, 'announcement_deleted', { announcementId: id });
  res.json({ success: true });
});

// --- Admin unit management ---
router.patch('/units/:id/status', (req, res) => {
  const { Units: U } = require('../db/sqlite');
  const unit = U.findById(parseInt(req.params.id, 10));
  if (!unit) return res.status(404).json({ error: 'Unit not found' });

  const { status } = req.body;
  if (status) {
    U.update(unit.id, { status });
    bus.emit('unit:update', { departmentId: unit.department_id, unit: U.findById(unit.id) });
  }
  res.json(U.findById(unit.id));
});

router.delete('/units/:id', (req, res) => {
  const { Units: U } = require('../db/sqlite');
  const unit = U.findById(parseInt(req.params.id, 10));
  if (!unit) return res.status(404).json({ error: 'Unit not found' });

  U.remove(unit.id);
  bus.emit('unit:offline', { departmentId: unit.department_id, unit });
  audit(req.user.id, 'admin_unit_removed', { unitId: unit.id, callsign: unit.callsign });
  res.json({ success: true });
});

module.exports = router;
